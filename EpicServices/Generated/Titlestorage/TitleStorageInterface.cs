// Copyright Epic Games, Inc. All Rights Reserved.
// This file is automatically generated. Changes to this file may be overwritten.

using System;
using System.Runtime.InteropServices;

namespace Epic.OnlineServices.TitleStorage
{
	public sealed class TitleStorageInterface : Handle
	{
		public TitleStorageInterface(IntPtr innerHandle) : base(innerHandle)
		{
		}

		/// <summary>
		/// The most recent version of the <see cref="DeleteCacheOptions" /> API.
		/// </summary>
		public const int DeletecacheoptionsApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="ReadFileOptions" /> API.
		/// </summary>
		public const int ReadfileoptionsApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="CopyFileMetadataByFilenameOptions" /> API.
		/// </summary>
		public const int CopyfilemetadatabyfilenameoptionsApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="CopyFileMetadataAtIndexOptions" /> API.
		/// </summary>
		public const int CopyfilemetadataatindexoptionsApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="GetFileMetadataCountOptions" /> API.
		/// </summary>
		public const int GetfilemetadatacountoptionsApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="QueryFileListOptions" /> API.
		/// </summary>
		public const int QueryfilelistoptionsApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="QueryFileOptions" /> API.
		/// </summary>
		public const int QueryfileoptionsApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="FileMetadata" /> API.
		/// </summary>
		public const int FilemetadataApiLatest = 1;

		/// <summary>
		/// Maximum File Name Length in bytes
		/// </summary>
		public const int FilenameMaxLengthBytes = 64;

		/// <summary>
		/// Query a specific file's metadata, such as file names, size, and a MD5 hash of the data. This is not required before a file may be opened. Once a file has
		/// been queried, its metadata will be available by the <see cref="CopyFileMetadataAtIndex" /> and <see cref="CopyFileMetadataByFilename" /> functions.
		/// <seealso cref="GetFileMetadataCount" />
		/// <seealso cref="CopyFileMetadataAtIndex" />
		/// <seealso cref="CopyFileMetadataByFilename" />
		/// </summary>
		/// <param name="options">Object containing properties related to which user is querying files, and what file is being queried</param>
		/// <param name="clientData">Optional pointer to help clients track this request, that is returned in the completion callback</param>
		/// <param name="completionCallback">This function is called when the query operation completes</param>
		public void QueryFile(QueryFileOptions options, object clientData, OnQueryFileCompleteCallback completionCallback)
		{
			var optionsInternal = Helper.CopyProperties<QueryFileOptionsInternal>(options);

			var completionCallbackInternal = new OnQueryFileCompleteCallbackInternal(OnQueryFileComplete);
			var clientDataAddress = IntPtr.Zero;
			Helper.AddCallback(ref clientDataAddress, clientData, completionCallback, completionCallbackInternal);

			EOS_TitleStorage_QueryFile(InnerHandle, ref optionsInternal, clientDataAddress, completionCallbackInternal);
			Helper.TryMarshalDispose(ref optionsInternal);
		}

		/// <summary>
		/// Query the file metadata, such as file names, size, and a MD5 hash of the data, for all files available for current user based on their settings (such as game role) and tags provided.
		/// This is not required before a file can be downloaded by name.
		/// </summary>
		/// <param name="options">Object containing properties related to which user is querying files and the list of tags</param>
		/// <param name="clientData">Optional pointer to help clients track this request, that is returned in the completion callback</param>
		/// <param name="completionCallback">This function is called when the query operation completes</param>
		public void QueryFileList(QueryFileListOptions options, object clientData, OnQueryFileListCompleteCallback completionCallback)
		{
			var optionsInternal = Helper.CopyProperties<QueryFileListOptionsInternal>(options);

			var completionCallbackInternal = new OnQueryFileListCompleteCallbackInternal(OnQueryFileListComplete);
			var clientDataAddress = IntPtr.Zero;
			Helper.AddCallback(ref clientDataAddress, clientData, completionCallback, completionCallbackInternal);

			EOS_TitleStorage_QueryFileList(InnerHandle, ref optionsInternal, clientDataAddress, completionCallbackInternal);
			Helper.TryMarshalDispose(ref optionsInternal);
		}

		/// <summary>
		/// Create a cached copy of a file's metadata by filename. The metadata will be for the last retrieved or successfully saved version, and will not include any changes that have not
		/// completed writing. The returned pointer must be released by the user when no longer needed.
		/// </summary>
		/// <param name="options">Object containing properties related to which user is requesting metadata, and for which filename</param>
		/// <param name="outMetadata">A copy of the FileMetadata structure will be set if successful. This data must be released by calling <see cref="Release" />.</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the metadata is currently cached, otherwise an error result explaining what went wrong
		/// </returns>
		public Result CopyFileMetadataByFilename(CopyFileMetadataByFilenameOptions options, out FileMetadata outMetadata)
		{
			var optionsInternal = Helper.CopyProperties<CopyFileMetadataByFilenameOptionsInternal>(options);

			outMetadata = Helper.GetDefault<FileMetadata>();

			var outMetadataAddress = IntPtr.Zero;

			var funcResult = EOS_TitleStorage_CopyFileMetadataByFilename(InnerHandle, ref optionsInternal, ref outMetadataAddress);
			Helper.TryMarshalDispose(ref optionsInternal);

			if (Helper.TryMarshalGet<FileMetadataInternal, FileMetadata>(outMetadataAddress, out outMetadata))
			{
				EOS_TitleStorage_FileMetadata_Release(outMetadataAddress);
			}

			var funcResultReturn = Helper.GetDefault<Result>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Get the count of files we have previously queried information for and files we have previously read from / written to.
		/// <seealso cref="CopyFileMetadataAtIndex" />
		/// </summary>
		/// <param name="options">Object containing properties related to which user is requesting the metadata count</param>
		/// <returns>
		/// If successful, the count of metadata currently cached. Returns 0 on failure.
		/// </returns>
		public uint GetFileMetadataCount(GetFileMetadataCountOptions options)
		{
			var optionsInternal = Helper.CopyProperties<GetFileMetadataCountOptionsInternal>(options);

			var funcResult = EOS_TitleStorage_GetFileMetadataCount(InnerHandle, ref optionsInternal);
			Helper.TryMarshalDispose(ref optionsInternal);

			var funcResultReturn = Helper.GetDefault<uint>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Get the cached copy of a file's metadata by index. The metadata will be for the last retrieved version. The returned pointer must be released by the user when no longer needed.
		/// <seealso cref="GetFileMetadataCount" />
		/// <seealso cref="Release" />
		/// </summary>
		/// <param name="options">Object containing properties related to which user is requesting metadata, and at what index</param>
		/// <param name="outMetadata">A copy of the FileMetadata structure will be set if successful. This data must be released by calling <see cref="Release" />.</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the requested metadata is currently cached, otherwise an error result explaining what went wrong.
		/// </returns>
		public Result CopyFileMetadataAtIndex(CopyFileMetadataAtIndexOptions options, out FileMetadata outMetadata)
		{
			var optionsInternal = Helper.CopyProperties<CopyFileMetadataAtIndexOptionsInternal>(options);

			outMetadata = Helper.GetDefault<FileMetadata>();

			var outMetadataAddress = IntPtr.Zero;

			var funcResult = EOS_TitleStorage_CopyFileMetadataAtIndex(InnerHandle, ref optionsInternal, ref outMetadataAddress);
			Helper.TryMarshalDispose(ref optionsInternal);

			if (Helper.TryMarshalGet<FileMetadataInternal, FileMetadata>(outMetadataAddress, out outMetadata))
			{
				EOS_TitleStorage_FileMetadata_Release(outMetadataAddress);
			}

			var funcResultReturn = Helper.GetDefault<Result>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Retrieve the contents of a specific file, potentially downloading the contents if we do not have a local copy, from the cloud. This request will occur asynchronously, potentially over
		/// multiple frames. All callbacks for this function will come from the same thread that the SDK is ticked from. If specified, the FileTransferProgressCallback will always be called at
		/// least once if the request is started successfully.
		/// <seealso cref="TitleStorageFileTransferRequest.Release" />
		/// </summary>
		/// <param name="options">Object containing properties related to which user is opening the file, what the file's name is, and related mechanisms for copying the data</param>
		/// <param name="clientData">Optional pointer to help clients track this request, that is returned in associated callbacks</param>
		/// <param name="completionCallback">This function is called when the read operation completes</param>
		/// <returns>
		/// A valid Title Storage File Request handle if successful, or NULL otherwise. Data contained in the completion callback will have more detailed information about issues with the request in failure cases. This handle must be released when it is no longer needed
		/// </returns>
		public TitleStorageFileTransferRequest ReadFile(ReadFileOptions options, object clientData, OnReadFileCompleteCallback completionCallback)
		{
			var optionsInternal = Helper.CopyProperties<ReadFileOptionsInternal>(options);

			var completionCallbackInternal = new OnReadFileCompleteCallbackInternal(OnReadFileComplete);
			var clientDataAddress = IntPtr.Zero;
			Helper.AddCallback(ref clientDataAddress, clientData, completionCallback, completionCallbackInternal, options.ReadFileDataCallback, optionsInternal.ReadFileDataCallback, options.FileTransferProgressCallback, optionsInternal.FileTransferProgressCallback);

			var funcResult = EOS_TitleStorage_ReadFile(InnerHandle, ref optionsInternal, clientDataAddress, completionCallbackInternal);
			Helper.TryMarshalDispose(ref optionsInternal);

			var funcResultReturn = Helper.GetDefault<TitleStorageFileTransferRequest>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Clear previously cached file data. This operation will be done asynchronously. All cached files except those corresponding to the transfers in progress will be removed.
		/// Warning: Use this with care. Cache system generally tries to clear old and unused cached files from time to time. Unnecessarily clearing cache can degrade performance as SDK will have to re-download data.
		/// </summary>
		/// <param name="options">Object containing properties related to which user is deleting cache</param>
		/// <param name="clientData">Optional pointer to help clients track this request, that is returned in associated callbacks</param>
		/// <param name="completionCallback">This function is called when the delete cache operation completes</param>
		/// <returns>
		/// <see cref="Result.Success" /> if the operation was started correctly, otherwise an error result explaining what went wrong
		/// </returns>
		public Result DeleteCache(DeleteCacheOptions options, object clientData, OnDeleteCacheCompleteCallback completionCallback)
		{
			var optionsInternal = Helper.CopyProperties<DeleteCacheOptionsInternal>(options);

			var completionCallbackInternal = new OnDeleteCacheCompleteCallbackInternal(OnDeleteCacheComplete);
			var clientDataAddress = IntPtr.Zero;
			Helper.AddCallback(ref clientDataAddress, clientData, completionCallback, completionCallbackInternal);

			var funcResult = EOS_TitleStorage_DeleteCache(InnerHandle, ref optionsInternal, clientDataAddress, completionCallbackInternal);
			Helper.TryMarshalDispose(ref optionsInternal);

			var funcResultReturn = Helper.GetDefault<Result>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		[MonoPInvokeCallback]
		internal static void OnFileTransferProgress(IntPtr callbackInfoAddress)
		{
			OnFileTransferProgressCallback callback = null;
			FileTransferProgressCallbackInfo callbackInfo = null;
			if (Helper.TryGetAdditionalCallback<OnFileTransferProgressCallback, FileTransferProgressCallbackInfoInternal, FileTransferProgressCallbackInfo>(callbackInfoAddress, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback]
		internal static ReadResult OnReadFileData(IntPtr callbackInfoAddress)
		{
			OnReadFileDataCallback callback = null;
			ReadFileDataCallbackInfo callbackInfo = null;
			if (Helper.TryGetAdditionalCallback<OnReadFileDataCallback, ReadFileDataCallbackInfoInternal, ReadFileDataCallbackInfo>(callbackInfoAddress, out callback, out callbackInfo))
			{
				var result = callback(callbackInfo);
				return result;
			}

			return Helper.GetDefault<ReadResult>();
		}

		[MonoPInvokeCallback]
		internal static void OnDeleteCacheComplete(IntPtr address)
		{
			OnDeleteCacheCompleteCallback callback = null;
			DeleteCacheCallbackInfo callbackInfo = null;
			if (Helper.TryGetAndRemoveCallback<OnDeleteCacheCompleteCallback, DeleteCacheCallbackInfoInternal, DeleteCacheCallbackInfo>(address, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback]
		internal static void OnReadFileComplete(IntPtr address)
		{
			OnReadFileCompleteCallback callback = null;
			ReadFileCallbackInfo callbackInfo = null;
			if (Helper.TryGetAndRemoveCallback<OnReadFileCompleteCallback, ReadFileCallbackInfoInternal, ReadFileCallbackInfo>(address, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback]
		internal static void OnQueryFileListComplete(IntPtr address)
		{
			OnQueryFileListCompleteCallback callback = null;
			QueryFileListCallbackInfo callbackInfo = null;
			if (Helper.TryGetAndRemoveCallback<OnQueryFileListCompleteCallback, QueryFileListCallbackInfoInternal, QueryFileListCallbackInfo>(address, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback]
		internal static void OnQueryFileComplete(IntPtr address)
		{
			OnQueryFileCompleteCallback callback = null;
			QueryFileCallbackInfo callbackInfo = null;
			if (Helper.TryGetAndRemoveCallback<OnQueryFileCompleteCallback, QueryFileCallbackInfoInternal, QueryFileCallbackInfo>(address, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[DllImport(Config.BinaryName)]
		private static extern void EOS_TitleStorage_FileMetadata_Release(IntPtr fileMetadata);

		[DllImport(Config.BinaryName)]
		private static extern Result EOS_TitleStorage_DeleteCache(IntPtr handle, ref DeleteCacheOptionsInternal options, IntPtr clientData, OnDeleteCacheCompleteCallbackInternal completionCallback);

		[DllImport(Config.BinaryName)]
		private static extern IntPtr EOS_TitleStorage_ReadFile(IntPtr handle, ref ReadFileOptionsInternal options, IntPtr clientData, OnReadFileCompleteCallbackInternal completionCallback);

		[DllImport(Config.BinaryName)]
		private static extern Result EOS_TitleStorage_CopyFileMetadataAtIndex(IntPtr handle, ref CopyFileMetadataAtIndexOptionsInternal options, ref IntPtr outMetadata);

		[DllImport(Config.BinaryName)]
		private static extern uint EOS_TitleStorage_GetFileMetadataCount(IntPtr handle, ref GetFileMetadataCountOptionsInternal options);

		[DllImport(Config.BinaryName)]
		private static extern Result EOS_TitleStorage_CopyFileMetadataByFilename(IntPtr handle, ref CopyFileMetadataByFilenameOptionsInternal options, ref IntPtr outMetadata);

		[DllImport(Config.BinaryName)]
		private static extern void EOS_TitleStorage_QueryFileList(IntPtr handle, ref QueryFileListOptionsInternal options, IntPtr clientData, OnQueryFileListCompleteCallbackInternal completionCallback);

		[DllImport(Config.BinaryName)]
		private static extern void EOS_TitleStorage_QueryFile(IntPtr handle, ref QueryFileOptionsInternal options, IntPtr clientData, OnQueryFileCompleteCallbackInternal completionCallback);
	}
}
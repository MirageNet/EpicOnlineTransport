// Copyright Epic Games, Inc. All Rights Reserved.
// This file is automatically generated. Changes to this file may be overwritten.

using System;
using System.Runtime.InteropServices;

namespace Epic.OnlineServices.P2P
{
	public sealed class P2PInterface : Handle
	{
		public P2PInterface(IntPtr innerHandle) : base(innerHandle)
		{
		}

		/// <summary>
		/// The most recent version of the <see cref="GetPortRange" /> API.
		/// </summary>
		public const int GetportrangeApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="SetPortRange" /> API.
		/// </summary>
		public const int SetportrangeApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="GetRelayControl" /> API.
		/// </summary>
		public const int GetrelaycontrolApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="SetRelayControl" /> API.
		/// </summary>
		public const int SetrelaycontrolApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="GetNATType" /> API.
		/// </summary>
		public const int GetnattypeApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="QueryNATType" /> API.
		/// </summary>
		public const int QuerynattypeApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="CloseConnections" /> API.
		/// </summary>
		public const int CloseconnectionsApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="CloseConnection" /> API.
		/// </summary>
		public const int CloseconnectionApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="AcceptConnection" /> API.
		/// </summary>
		public const int AcceptconnectionApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="AddNotifyPeerConnectionClosed" /> API.
		/// </summary>
		public const int AddnotifypeerconnectionclosedApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="AddNotifyPeerConnectionRequest" /> API.
		/// </summary>
		public const int AddnotifypeerconnectionrequestApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="ReceivePacket" /> API.
		/// </summary>
		public const int ReceivepacketApiLatest = 2;

		/// <summary>
		/// The most recent version of the <see cref="GetNextReceivedPacketSize" /> API.
		/// </summary>
		public const int GetnextreceivedpacketsizeApiLatest = 2;

		/// <summary>
		/// The most recent version of the <see cref="SendPacket" /> API.
		/// </summary>
		public const int SendpacketApiLatest = 2;

		/// <summary>
		/// The most recent version of the <see cref="SocketId" /> structure.
		/// </summary>
		public const int SocketidApiLatest = 1;

		/// <summary>
		/// The maximum amount of unique Socket ID connections that can be opened with each remote user. As this limit is only per remote user, you may have more
		/// than this number of Socket IDs across multiple remote users.
		/// </summary>
		public const int MaxConnections = 32;

		/// <summary>
		/// A packet's maximum size in bytes
		/// </summary>
		public const int MaxPacketSize = 1170;

		/// <summary>
		/// Send a packet to a peer at the specified address. If there is already an open connection to this peer, it will be
		/// sent immediately. If there is no open connection, an attempt to connect to the peer will be made. An <see cref="Result.Success" />
		/// result only means the data was accepted to be sent, not that it has been successfully delivered to the peer.
		/// </summary>
		/// <param name="options">Information about the data being sent, by who, to who</param>
		/// <returns>
		/// <see cref="Result" />::<see cref="Result.Success" />      - If packet was queued to be sent successfully
		/// <see cref="Result" />::<see cref="Result.InvalidParameters" /> - If input was invalid
		/// <see cref="Result" />::<see cref="Result.LimitExceeded" />   - If amount of data being sent is too large
		/// </returns>
		public Result SendPacket(SendPacketOptions options)
		{
			var optionsInternal = Helper.CopyProperties<SendPacketOptionsInternal>(options);

			var funcResult = EOS_P2P_SendPacket(InnerHandle, ref optionsInternal);
			Helper.TryMarshalDispose(ref optionsInternal);

			var funcResultReturn = Helper.GetDefault<Result>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Gets the size of the packet that will be returned by ReceivePacket for a particular user, if there is any available
		/// packets to be retrieved.
		/// </summary>
		/// <param name="options">Information about who is requesting the size of their next packet</param>
		/// <param name="outPacketSizeBytes">The amount of bytes required to store the data of the next packet for the requested user</param>
		/// <returns>
		/// <see cref="Result" />::<see cref="Result.Success" /> - If OutPacketSizeBytes was successfully set and there is data to be received
		/// <see cref="Result" />::<see cref="Result.InvalidParameters" /> - If input was invalid
		/// <see cref="Result" />::<see cref="Result.NotFound" /> - If there are no packets available for the requesting user
		/// </returns>
		public Result GetNextReceivedPacketSize(GetNextReceivedPacketSizeOptions options, out uint outPacketSizeBytes)
		{
			var optionsInternal = Helper.CopyProperties<GetNextReceivedPacketSizeOptionsInternal>(options);

			outPacketSizeBytes = Helper.GetDefault<uint>();

			var funcResult = EOS_P2P_GetNextReceivedPacketSize(InnerHandle, ref optionsInternal, ref outPacketSizeBytes);
			Helper.TryMarshalDispose(ref optionsInternal);

			var funcResultReturn = Helper.GetDefault<Result>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Receive the next packet for the local user, and information associated with this packet, if it exists.
		/// </summary>
		/// <param name="options">Information about who is requesting the size of their next packet, and how much data can be stored safely</param>
		/// <param name="outPeerId">The Remote User who sent data. Only set if there was a packet to receive.</param>
		/// <param name="outSocketId">The Socket ID of the data that was sent. Only set if there was a packet to receive.</param>
		/// <param name="outChannel">The channel the data was sent on. Only set if there was a packet to receive.</param>
		/// <param name="outData">Buffer to store the data being received. Must be at least <see cref="GetNextReceivedPacketSize" /> in length or data will be truncated</param>
		/// <param name="outBytesWritten">The amount of bytes written to OutData. Only set if there was a packet to receive.</param>
		/// <returns>
		/// <see cref="Result" />::<see cref="Result.Success" /> - If the packet was received successfully
		/// <see cref="Result" />::<see cref="Result.InvalidParameters" /> - If input was invalid
		/// <see cref="Result" />::<see cref="Result.NotFound" /> - If there are no packets available for the requesting user
		/// </returns>
		public Result ReceivePacket(ReceivePacketOptions options, out ProductUserId outPeerId, out SocketId outSocketId, out byte outChannel, ref byte[] outData, out uint outBytesWritten)
		{
			var optionsInternal = Helper.CopyProperties<ReceivePacketOptionsInternal>(options);

			outPeerId = Helper.GetDefault<ProductUserId>();

			var outPeerIdAddress = IntPtr.Zero;

			outSocketId = Helper.GetDefault<SocketId>();

			var outSocketIdInternal = new SocketIdInternal();

			outChannel = Helper.GetDefault<byte>();

			outBytesWritten = Helper.GetDefault<uint>();

			var funcResult = EOS_P2P_ReceivePacket(InnerHandle, ref optionsInternal, ref outPeerIdAddress, ref outSocketIdInternal, ref outChannel, outData, ref outBytesWritten);
			Helper.TryMarshalDispose(ref optionsInternal);

			Helper.TryMarshalGet(outPeerIdAddress, out outPeerId);
			outSocketId = Helper.CopyProperties<SocketId>(outSocketIdInternal);
			Helper.TryMarshalDispose(ref outSocketIdInternal);

			var funcResultReturn = Helper.GetDefault<Result>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Listen for incoming connection requests on a particular Socket ID, or optionally all Socket IDs. The bound function
		/// will only be called if the connection has not already been accepted.
		/// </summary>
		/// <param name="options">Information about who would like notifications, and (optionally) only for a specific socket</param>
		/// <param name="clientData">This value is returned to the caller when ConnectionRequestHandler is invoked</param>
		/// <param name="connectionRequestHandler">The callback to be fired when we receive a connection request</param>
		/// <returns>
		/// A valid notification ID if successfully bound, or <see cref="Common.InvalidNotificationid" /> otherwise
		/// </returns>
		public ulong AddNotifyPeerConnectionRequest(AddNotifyPeerConnectionRequestOptions options, object clientData, OnIncomingConnectionRequestCallback connectionRequestHandler)
		{
			var optionsInternal = Helper.CopyProperties<AddNotifyPeerConnectionRequestOptionsInternal>(options);

			var connectionRequestHandlerInternal = new OnIncomingConnectionRequestCallbackInternal(OnIncomingConnectionRequest);
			var clientDataAddress = IntPtr.Zero;
			Helper.AddCallback(ref clientDataAddress, clientData, connectionRequestHandler, connectionRequestHandlerInternal);

			var funcResult = EOS_P2P_AddNotifyPeerConnectionRequest(InnerHandle, ref optionsInternal, clientDataAddress, connectionRequestHandlerInternal);
			Helper.TryMarshalDispose(ref optionsInternal);

			Helper.TryAssignNotificationIdToCallback(clientDataAddress, funcResult);

			var funcResultReturn = Helper.GetDefault<ulong>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Stop listening for connection requests on a previously bound handler
		/// </summary>
		/// <param name="notificationId">The previously bound notification ID</param>
		public void RemoveNotifyPeerConnectionRequest(ulong notificationId)
		{
			Helper.TryRemoveCallbackByNotificationId(notificationId);
			EOS_P2P_RemoveNotifyPeerConnectionRequest(InnerHandle, notificationId);
		}

		/// <summary>
		/// Listen for when a previously opened connection is closed
		/// </summary>
		/// <param name="options">Information about who would like notifications about closed connections, and for which socket</param>
		/// <param name="clientData">This value is returned to the caller when ConnectionClosedHandler is invoked</param>
		/// <param name="connectionClosedHandler">The callback to be fired when we an open connection has been closed</param>
		/// <returns>
		/// A valid notification ID if successfully bound, or <see cref="Common.InvalidNotificationid" /> otherwise
		/// </returns>
		public ulong AddNotifyPeerConnectionClosed(AddNotifyPeerConnectionClosedOptions options, object clientData, OnRemoteConnectionClosedCallback connectionClosedHandler)
		{
			var optionsInternal = Helper.CopyProperties<AddNotifyPeerConnectionClosedOptionsInternal>(options);

			var connectionClosedHandlerInternal = new OnRemoteConnectionClosedCallbackInternal(OnRemoteConnectionClosed);
			var clientDataAddress = IntPtr.Zero;
			Helper.AddCallback(ref clientDataAddress, clientData, connectionClosedHandler, connectionClosedHandlerInternal);

			var funcResult = EOS_P2P_AddNotifyPeerConnectionClosed(InnerHandle, ref optionsInternal, clientDataAddress, connectionClosedHandlerInternal);
			Helper.TryMarshalDispose(ref optionsInternal);

			Helper.TryAssignNotificationIdToCallback(clientDataAddress, funcResult);

			var funcResultReturn = Helper.GetDefault<ulong>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Stop notifications for connections being closed on a previously bound handler
		/// </summary>
		/// <param name="notificationId">The previously bound notification ID</param>
		public void RemoveNotifyPeerConnectionClosed(ulong notificationId)
		{
			Helper.TryRemoveCallbackByNotificationId(notificationId);
			EOS_P2P_RemoveNotifyPeerConnectionClosed(InnerHandle, notificationId);
		}

		/// <summary>
		/// Accept connections from a specific peer. If this peer has not attempted to connect yet, when they do, they will automatically be accepted.
		/// </summary>
		/// <param name="options">Information about who would like to accept a connection, and which connection</param>
		/// <returns>
		/// <see cref="Result" />::<see cref="Result.Success" /> - if the provided data is valid
		/// <see cref="Result" />::<see cref="Result.InvalidParameters" /> - if the provided data is invalid
		/// </returns>
		public Result AcceptConnection(AcceptConnectionOptions options)
		{
			var optionsInternal = Helper.CopyProperties<AcceptConnectionOptionsInternal>(options);

			var funcResult = EOS_P2P_AcceptConnection(InnerHandle, ref optionsInternal);
			Helper.TryMarshalDispose(ref optionsInternal);

			var funcResultReturn = Helper.GetDefault<Result>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Stop accepting new connections from a specific peer and close any open connections.
		/// </summary>
		/// <param name="options">Information about who would like to close a connection, and which connection.</param>
		/// <returns>
		/// <see cref="Result" />::<see cref="Result.Success" /> - if the provided data is valid
		/// <see cref="Result" />::<see cref="Result.InvalidParameters" /> - if the provided data is invalid
		/// </returns>
		public Result CloseConnection(CloseConnectionOptions options)
		{
			var optionsInternal = Helper.CopyProperties<CloseConnectionOptionsInternal>(options);

			var funcResult = EOS_P2P_CloseConnection(InnerHandle, ref optionsInternal);
			Helper.TryMarshalDispose(ref optionsInternal);

			var funcResultReturn = Helper.GetDefault<Result>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Close any open Connections for a specific Peer Connection ID.
		/// </summary>
		/// <param name="options">Information about who would like to close connections, and by what socket ID</param>
		/// <returns>
		/// <see cref="Result" />::<see cref="Result.Success" /> - if the provided data is valid
		/// <see cref="Result" />::<see cref="Result.InvalidParameters" /> - if the provided data is invalid
		/// </returns>
		public Result CloseConnections(CloseConnectionsOptions options)
		{
			var optionsInternal = Helper.CopyProperties<CloseConnectionsOptionsInternal>(options);

			var funcResult = EOS_P2P_CloseConnections(InnerHandle, ref optionsInternal);
			Helper.TryMarshalDispose(ref optionsInternal);

			var funcResultReturn = Helper.GetDefault<Result>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Query the current NAT-type of our connection.
		/// </summary>
		/// <param name="options">Information about what version of the <see cref="QueryNATType" /> API is supported</param>
		/// <param name="nATTypeQueriedHandler">The callback to be fired when we finish querying our NAT type</param>
		public void QueryNATType(QueryNATTypeOptions options, object clientData, OnQueryNATTypeCompleteCallback nATTypeQueriedHandler)
		{
			var optionsInternal = Helper.CopyProperties<QueryNATTypeOptionsInternal>(options);

			var nATTypeQueriedHandlerInternal = new OnQueryNATTypeCompleteCallbackInternal(OnQueryNATTypeComplete);
			var clientDataAddress = IntPtr.Zero;
			Helper.AddCallback(ref clientDataAddress, clientData, nATTypeQueriedHandler, nATTypeQueriedHandlerInternal);

			EOS_P2P_QueryNATType(InnerHandle, ref optionsInternal, clientDataAddress, nATTypeQueriedHandlerInternal);
			Helper.TryMarshalDispose(ref optionsInternal);
		}

		/// <summary>
		/// Get our last-queried NAT-type, if it has been successfully queried.
		/// </summary>
		/// <param name="options">Information about what version of the <see cref="GetNATType" /> API is supported</param>
		/// <param name="outNATType">The queried NAT Type, or unknown if unknown</param>
		/// <returns>
		/// <see cref="Result" />::<see cref="Result.Success" /> - if we have cached data
		/// <see cref="Result" />::<see cref="Result.NotFound" /> - If we do not have queried data cached
		/// </returns>
		public Result GetNATType(GetNATTypeOptions options, out NATType outNATType)
		{
			var optionsInternal = Helper.CopyProperties<GetNATTypeOptionsInternal>(options);

			outNATType = Helper.GetDefault<NATType>();

			var funcResult = EOS_P2P_GetNATType(InnerHandle, ref optionsInternal, ref outNATType);
			Helper.TryMarshalDispose(ref optionsInternal);

			var funcResultReturn = Helper.GetDefault<Result>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Set how relay servers are to be used. This setting does not immediately apply to existing connections, but may apply to existing
		/// connections if the connection requires renegotiation.
		/// </summary>
		/// <param name="options">Information about relay server config options</param>
		/// <returns>
		/// <see cref="Result" />::<see cref="Result.Success" /> - if the options were set successfully
		/// <see cref="Result" />::<see cref="Result.InvalidParameters" /> - if the options are invalid in some way
		/// </returns>
		public Result SetRelayControl(SetRelayControlOptions options)
		{
			var optionsInternal = Helper.CopyProperties<SetRelayControlOptionsInternal>(options);

			var funcResult = EOS_P2P_SetRelayControl(InnerHandle, ref optionsInternal);
			Helper.TryMarshalDispose(ref optionsInternal);

			var funcResultReturn = Helper.GetDefault<Result>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Get the current relay control setting.
		/// </summary>
		/// <param name="options">Information about what version of the <see cref="GetRelayControl" /> API is supported</param>
		/// <param name="outRelayControl">The relay control setting currently configured</param>
		/// <returns>
		/// <see cref="Result" />::<see cref="Result.Success" /> - if the input was valid
		/// <see cref="Result" />::<see cref="Result.InvalidParameters" /> - if the input was invalid in some way
		/// </returns>
		public Result GetRelayControl(GetRelayControlOptions options, out RelayControl outRelayControl)
		{
			var optionsInternal = Helper.CopyProperties<GetRelayControlOptionsInternal>(options);

			outRelayControl = Helper.GetDefault<RelayControl>();

			var funcResult = EOS_P2P_GetRelayControl(InnerHandle, ref optionsInternal, ref outRelayControl);
			Helper.TryMarshalDispose(ref optionsInternal);

			var funcResultReturn = Helper.GetDefault<Result>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Set configuration options related to network ports.
		/// </summary>
		/// <param name="options">Information about network ports config options</param>
		/// <returns>
		/// <see cref="Result" />::<see cref="Result.Success" /> - if the options were set successfully
		/// <see cref="Result" />::<see cref="Result.InvalidParameters" /> - if the options are invalid in some way
		/// </returns>
		public Result SetPortRange(SetPortRangeOptions options)
		{
			var optionsInternal = Helper.CopyProperties<SetPortRangeOptionsInternal>(options);

			var funcResult = EOS_P2P_SetPortRange(InnerHandle, ref optionsInternal);
			Helper.TryMarshalDispose(ref optionsInternal);

			var funcResultReturn = Helper.GetDefault<Result>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Get the current chosen port and the amount of other ports to try above the chosen port if the chosen port is unavailable.
		/// </summary>
		/// <param name="options">Information about what version of the <see cref="GetPortRange" /> API is supported</param>
		/// <param name="outPort">The port that will be tried first</param>
		/// <param name="outNumAdditionalPortsToTry">The amount of ports to try above the value in OutPort, if OutPort is unavailable</param>
		/// <returns>
		/// <see cref="Result" />::<see cref="Result.Success" /> - if the input options were valid
		/// <see cref="Result" />::<see cref="Result.InvalidParameters" /> - if the input was invalid in some way
		/// </returns>
		public Result GetPortRange(GetPortRangeOptions options, out ushort outPort, out ushort outNumAdditionalPortsToTry)
		{
			var optionsInternal = Helper.CopyProperties<GetPortRangeOptionsInternal>(options);

			outPort = Helper.GetDefault<ushort>();

			outNumAdditionalPortsToTry = Helper.GetDefault<ushort>();

			var funcResult = EOS_P2P_GetPortRange(InnerHandle, ref optionsInternal, ref outPort, ref outNumAdditionalPortsToTry);
			Helper.TryMarshalDispose(ref optionsInternal);

			var funcResultReturn = Helper.GetDefault<Result>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		[MonoPInvokeCallback]
		internal static void OnQueryNATTypeComplete(IntPtr address)
		{
			OnQueryNATTypeCompleteCallback callback = null;
			OnQueryNATTypeCompleteInfo callbackInfo = null;
			if (Helper.TryGetAndRemoveCallback<OnQueryNATTypeCompleteCallback, OnQueryNATTypeCompleteInfoInternal, OnQueryNATTypeCompleteInfo>(address, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback]
		internal static void OnRemoteConnectionClosed(IntPtr address)
		{
			OnRemoteConnectionClosedCallback callback = null;
			OnRemoteConnectionClosedInfo callbackInfo = null;
			if (Helper.TryGetAndRemoveCallback<OnRemoteConnectionClosedCallback, OnRemoteConnectionClosedInfoInternal, OnRemoteConnectionClosedInfo>(address, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback]
		internal static void OnIncomingConnectionRequest(IntPtr address)
		{
			OnIncomingConnectionRequestCallback callback = null;
			OnIncomingConnectionRequestInfo callbackInfo = null;
			if (Helper.TryGetAndRemoveCallback<OnIncomingConnectionRequestCallback, OnIncomingConnectionRequestInfoInternal, OnIncomingConnectionRequestInfo>(address, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[DllImport(Config.BinaryName)]
		private static extern Result EOS_P2P_GetPortRange(IntPtr handle, ref GetPortRangeOptionsInternal options, ref ushort outPort, ref ushort outNumAdditionalPortsToTry);

		[DllImport(Config.BinaryName)]
		private static extern Result EOS_P2P_SetPortRange(IntPtr handle, ref SetPortRangeOptionsInternal options);

		[DllImport(Config.BinaryName)]
		private static extern Result EOS_P2P_GetRelayControl(IntPtr handle, ref GetRelayControlOptionsInternal options, ref RelayControl outRelayControl);

		[DllImport(Config.BinaryName)]
		private static extern Result EOS_P2P_SetRelayControl(IntPtr handle, ref SetRelayControlOptionsInternal options);

		[DllImport(Config.BinaryName)]
		private static extern Result EOS_P2P_GetNATType(IntPtr handle, ref GetNATTypeOptionsInternal options, ref NATType outNATType);

		[DllImport(Config.BinaryName)]
		private static extern void EOS_P2P_QueryNATType(IntPtr handle, ref QueryNATTypeOptionsInternal options, IntPtr clientData, OnQueryNATTypeCompleteCallbackInternal nATTypeQueriedHandler);

		[DllImport(Config.BinaryName)]
		private static extern Result EOS_P2P_CloseConnections(IntPtr handle, ref CloseConnectionsOptionsInternal options);

		[DllImport(Config.BinaryName)]
		private static extern Result EOS_P2P_CloseConnection(IntPtr handle, ref CloseConnectionOptionsInternal options);

		[DllImport(Config.BinaryName)]
		private static extern Result EOS_P2P_AcceptConnection(IntPtr handle, ref AcceptConnectionOptionsInternal options);

		[DllImport(Config.BinaryName)]
		private static extern void EOS_P2P_RemoveNotifyPeerConnectionClosed(IntPtr handle, ulong notificationId);

		[DllImport(Config.BinaryName)]
		private static extern ulong EOS_P2P_AddNotifyPeerConnectionClosed(IntPtr handle, ref AddNotifyPeerConnectionClosedOptionsInternal options, IntPtr clientData, OnRemoteConnectionClosedCallbackInternal connectionClosedHandler);

		[DllImport(Config.BinaryName)]
		private static extern void EOS_P2P_RemoveNotifyPeerConnectionRequest(IntPtr handle, ulong notificationId);

		[DllImport(Config.BinaryName)]
		private static extern ulong EOS_P2P_AddNotifyPeerConnectionRequest(IntPtr handle, ref AddNotifyPeerConnectionRequestOptionsInternal options, IntPtr clientData, OnIncomingConnectionRequestCallbackInternal connectionRequestHandler);

		[DllImport(Config.BinaryName)]
		private static extern Result EOS_P2P_ReceivePacket(IntPtr handle, ref ReceivePacketOptionsInternal options, ref IntPtr outPeerId, ref SocketIdInternal outSocketId, ref byte outChannel, byte[] outData, ref uint outBytesWritten);

		[DllImport(Config.BinaryName)]
		private static extern Result EOS_P2P_GetNextReceivedPacketSize(IntPtr handle, ref GetNextReceivedPacketSizeOptionsInternal options, ref uint outPacketSizeBytes);

		[DllImport(Config.BinaryName)]
		private static extern Result EOS_P2P_SendPacket(IntPtr handle, ref SendPacketOptionsInternal options);
	}
}
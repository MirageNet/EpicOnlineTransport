// Copyright Epic Games, Inc. All Rights Reserved.
// This file is automatically generated. Changes to this file may be overwritten.

using System;
using System.Runtime.InteropServices;

namespace Epic.OnlineServices.Connect
{
	public sealed class ConnectInterface : Handle
	{
		public ConnectInterface(IntPtr innerHandle) : base(innerHandle)
		{
		}

		/// <summary>
		/// The most recent version of the <see cref="AddNotifyLoginStatusChanged" /> API.
		/// </summary>
		public const int AddnotifyloginstatuschangedApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="OnAuthExpirationCallback" /> API.
		/// </summary>
		public const int OnauthexpirationcallbackApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="AddNotifyAuthExpiration" /> API.
		/// </summary>
		public const int AddnotifyauthexpirationApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="ExternalAccountInfo" /> struct.
		/// </summary>
		public const int ExternalaccountinfoApiLatest = 1;

		/// <summary>
		/// Timestamp value representing an undefined time for last login time.
		/// </summary>
		public const int TimeUndefined = -1;

		/// <summary>
		/// The most recent version of the <see cref="CopyProductUserInfo" /> API.
		/// </summary>
		public const int CopyproductuserinfoApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="CopyProductUserExternalAccountByAccountId" /> API.
		/// </summary>
		public const int CopyproductuserexternalaccountbyaccountidApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="CopyProductUserExternalAccountByAccountType" /> API.
		/// </summary>
		public const int CopyproductuserexternalaccountbyaccounttypeApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="CopyProductUserExternalAccountByIndex" /> API.
		/// </summary>
		public const int CopyproductuserexternalaccountbyindexApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="GetProductUserExternalAccountCount" /> API.
		/// </summary>
		public const int GetproductuserexternalaccountcountApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="GetProductUserIdMapping" /> API.
		/// </summary>
		public const int GetproductuseridmappingApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="QueryProductUserIdMappings" /> API.
		/// </summary>
		public const int QueryproductuseridmappingsApiLatest = 2;

		/// <summary>
		/// DEPRECATED! Use <see cref="GetexternalaccountmappingApiLatest" /> instead.
		/// </summary>
		public const int GetexternalaccountmappingsApiLatest = GetexternalaccountmappingApiLatest;

		/// <summary>
		/// The most recent version of the <see cref="GetExternalAccountMapping" /> API.
		/// </summary>
		public const int GetexternalaccountmappingApiLatest = 1;

		/// <summary>
		/// Maximum number of account IDs that can be queried at once
		/// </summary>
		public const int QueryexternalaccountmappingsMaxAccountIds = 128;

		/// <summary>
		/// The most recent version of the <see cref="QueryExternalAccountMappings" /> API.
		/// </summary>
		public const int QueryexternalaccountmappingsApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="TransferDeviceIdAccount" /> API.
		/// </summary>
		public const int TransferdeviceidaccountApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="DeleteDeviceId" /> API.
		/// </summary>
		public const int DeletedeviceidApiLatest = 1;

		/// <summary>
		/// Max length of a device model name, not including the terminating null
		/// </summary>
		public const int CreatedeviceidDevicemodelMaxLength = 64;

		/// <summary>
		/// The most recent version of the <see cref="CreateDeviceId" /> API.
		/// </summary>
		public const int CreatedeviceidApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="UnlinkAccount" /> API.
		/// </summary>
		public const int UnlinkaccountApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="LinkAccount" /> API.
		/// </summary>
		public const int LinkaccountApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="CreateUser" /> API.
		/// </summary>
		public const int CreateuserApiLatest = 1;

		/// <summary>
		/// The most recent version of the <see cref="Login" /> API.
		/// </summary>
		public const int LoginApiLatest = 2;

		/// <summary>
		/// The most recent version of the <see cref="UserLoginInfo" /> struct.
		/// </summary>
		public const int UserlogininfoApiLatest = 1;

		/// <summary>
		/// Max length of a display name, not including the terminating null
		/// </summary>
		public const int UserlogininfoDisplaynameMaxLength = 32;

		/// <summary>
		/// The most recent version of the <see cref="Credentials" /> struct.
		/// </summary>
		public const int CredentialsApiLatest = 1;

		/// <summary>
		/// Max length of an external account ID in string form
		/// </summary>
		public const int ExternalAccountIdMaxLength = 256;

		/// <summary>
		/// Login/Authenticate given a valid set of external auth credentials.
		/// </summary>
		/// <param name="options">structure containing the external account credentials and type to use during the login operation</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">a callback that is fired when the login operation completes, either successfully or in error</param>
		public void Login(LoginOptions options, object clientData, OnLoginCallback completionDelegate)
		{
			var optionsInternal = Helper.CopyProperties<LoginOptionsInternal>(options);

			var completionDelegateInternal = new OnLoginCallbackInternal(OnLogin);
			var clientDataAddress = IntPtr.Zero;
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			EOS_Connect_Login(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);
			Helper.TryMarshalDispose(ref optionsInternal);
		}

		/// <summary>
		/// Create an account association with the Epic Online Service as a product user given their external auth credentials
		/// </summary>
		/// <param name="options">structure containing a continuance token from a "user not found" response during Login (always try login first)</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">a callback that is fired when the create operation completes, either successfully or in error</param>
		public void CreateUser(CreateUserOptions options, object clientData, OnCreateUserCallback completionDelegate)
		{
			var optionsInternal = Helper.CopyProperties<CreateUserOptionsInternal>(options);

			var completionDelegateInternal = new OnCreateUserCallbackInternal(OnCreateUser);
			var clientDataAddress = IntPtr.Zero;
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			EOS_Connect_CreateUser(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);
			Helper.TryMarshalDispose(ref optionsInternal);
		}

		/// <summary>
		/// Link a set of external auth credentials with an existing product user on the Epic Online Service
		/// </summary>
		/// <param name="options">structure containing a continuance token from a "user not found" response during Login (always try login first) and a currently logged in user not already associated with this external auth provider</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">a callback that is fired when the link operation completes, either successfully or in error</param>
		public void LinkAccount(LinkAccountOptions options, object clientData, OnLinkAccountCallback completionDelegate)
		{
			var optionsInternal = Helper.CopyProperties<LinkAccountOptionsInternal>(options);

			var completionDelegateInternal = new OnLinkAccountCallbackInternal(OnLinkAccount);
			var clientDataAddress = IntPtr.Zero;
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			EOS_Connect_LinkAccount(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);
			Helper.TryMarshalDispose(ref optionsInternal);
		}

		/// <summary>
		/// Unlink external auth credentials from the owning keychain of a logged in product user.
		/// 
		/// This function allows recovering the user from scenarios where they have accidentally proceeded to creating
		/// a new product user for the local native user account, instead of linking it with an existing keychain that
		/// they have previously created by playing the game (or another game owned by the organization) on another platform.
		/// 
		/// In such scenario, after the initial platform login and a new product user creation, the user wishes to re-login
		/// using other set of external auth credentials to connect with their existing game progression data. In order to
		/// allow automatic login also on the current platform, they will need to unlink the accidentally created new keychain
		/// and product user and then use the <see cref="Login" /> and <see cref="LinkAccount" /> APIs to link the local native platform
		/// account with that previously created existing product user and its owning keychain.
		/// 
		/// In another secnario, the user may simply want to disassociate the account that they have logged in with from the current
		/// keychain that it is linked with, perhaps to link it against another keychain or to separate the game progressions again.
		/// 
		/// In order to protect against account theft, it is only possible to unlink user accounts that have been authenticated
		/// and logged in to the product user in the current session. This prevents a malicious actor from gaining access to one
		/// of the linked accounts and using it to remove all other accounts linked with the keychain. This also prevents a malicious
		/// actor from replacing the unlinked account with their own corresponding account on the same platform, as the unlinking
		/// operation will ensure that any existing authentication session cannot be used to re-link and overwrite the entry without
		/// authenticating with one of the other linked accounts in the keychain. These restrictions limit the potential attack surface
		/// related to account theft scenarios.
		/// </summary>
		/// <param name="options">structure containing operation input parameters</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">a callback that is fired when the unlink operation completes, either successfully or in error</param>
		public void UnlinkAccount(UnlinkAccountOptions options, object clientData, OnUnlinkAccountCallback completionDelegate)
		{
			var optionsInternal = Helper.CopyProperties<UnlinkAccountOptionsInternal>(options);

			var completionDelegateInternal = new OnUnlinkAccountCallbackInternal(OnUnlinkAccount);
			var clientDataAddress = IntPtr.Zero;
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			EOS_Connect_UnlinkAccount(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);
			Helper.TryMarshalDispose(ref optionsInternal);
		}

		/// <summary>
		/// Create a new unique pseudo-account that can be used to identify the current user profile on the local device.
		/// 
		/// This function is intended to be used by mobile games and PC games that wish to allow
		/// a new user to start playing without requiring to login to the game using any user identity.
		/// In addition to this, the Device ID feature is used to automatically login the local user
		/// also when they have linked at least one external user account(s) with the local Device ID.
		/// 
		/// It is possible to link many devices with the same user's account keyring using the Device ID feature.
		/// 
		/// Linking a device later or immediately with a real user account will ensure that the player
		/// will not lose their progress if they switch devices or lose the device at some point,
		/// as they will be always able to login with one of their linked real accounts and also link
		/// another new device with the user account associations keychain. Otherwise, without having
		/// at least one permanent user account linked to the Device ID, the player would lose all of their
		/// game data and progression permanently should something happen to their device or the local
		/// user profile on the device.
		/// 
		/// After a successful one-time CreateDeviceId operation, the game can login the local user
		/// automatically on subsequent game starts with <see cref="Login" /> using the <see cref="ExternalCredentialType.DeviceidAccessToken" />
		/// credentials type. If a Device ID already exists for the local user on the device then <see cref="Result.DuplicateNotAllowed" />
		/// error result is returned and the caller should proceed to calling <see cref="Login" /> directly.
		/// </summary>
		/// <param name="options">structure containing operation input parameters</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">a callback that is fired when the create operation completes, either successfully or in error</param>
		public void CreateDeviceId(CreateDeviceIdOptions options, object clientData, OnCreateDeviceIdCallback completionDelegate)
		{
			var optionsInternal = Helper.CopyProperties<CreateDeviceIdOptionsInternal>(options);

			var completionDelegateInternal = new OnCreateDeviceIdCallbackInternal(OnCreateDeviceId);
			var clientDataAddress = IntPtr.Zero;
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			EOS_Connect_CreateDeviceId(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);
			Helper.TryMarshalDispose(ref optionsInternal);
		}

		/// <summary>
		/// Delete any existing Device ID access credentials for the current user profile on the local device.
		/// 
		/// The deletion is permanent and it is not possible to recover lost game data and progression
		/// if the Device ID had not been linked with at least one real external user account.
		/// </summary>
		/// <param name="options">structure containing operation input parameters</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">a callback that is fired when the delete operation completes, either successfully or in error</param>
		public void DeleteDeviceId(DeleteDeviceIdOptions options, object clientData, OnDeleteDeviceIdCallback completionDelegate)
		{
			var optionsInternal = Helper.CopyProperties<DeleteDeviceIdOptionsInternal>(options);

			var completionDelegateInternal = new OnDeleteDeviceIdCallbackInternal(OnDeleteDeviceId);
			var clientDataAddress = IntPtr.Zero;
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			EOS_Connect_DeleteDeviceId(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);
			Helper.TryMarshalDispose(ref optionsInternal);
		}

		/// <summary>
		/// Transfer a Device ID pseudo-account and the product user associated with it into another
		/// keychain linked with real user accounts (such as Epic Games, Playstation, Xbox, and other).
		/// 
		/// This function allows transferring a product user, i.e. the local user's game progression
		/// backend data from a Device ID owned keychain into a keychain with real user accounts
		/// linked to it. The transfer of Device ID owned product user into a keychain of real user
		/// accounts allows persisting the user's game data on the backend in the event that they
		/// would lose access to the local device or otherwise switch to another device or platform.
		/// 
		/// This function is only applicable in the situation of where the local user first plays
		/// the game using the anonymous Device ID login, then later logs in using a real user
		/// account that they have also already used to play the same game or another game under the
		/// same organization within Epic Online Services. In such situation, while normally the login
		/// attempt with a real user account would return <see cref="Result.InvalidUser" /> and an <see cref="ContinuanceToken" />
		/// and allow calling the <see cref="LinkAccount" /> API to link it with the Device ID's keychain,
		/// instead the login operation succeeds and finds an existing user because the association
		/// already exists. Because the user cannot have two product users simultaneously to play with,
		/// the game should prompt the user to choose which profile to keep and which one to discard
		/// permanently. Based on the user choice, the game may then proceed to transfer the Device ID
		/// login into the keychain that is persistent and backed by real user accounts, and if the user
		/// chooses so, move the product user as well into the destination keychain and overwrite the
		/// existing previous product user with it. To clarify, moving the product user with the Device ID
		/// login in this way into a persisted keychain allows to preserve the so far only locally persisted
		/// game progression and thus protect the user against a case where they lose access to the device.
		/// 
		/// On success, the completion callback will return the preserved <see cref="ProductUserId" /> that remains
		/// logged in while the discarded <see cref="ProductUserId" /> has been invalidated and deleted permanently.
		/// Consecutive logins using the existing Device ID login type or the external account will
		/// connect the user to the same backend data belonging to the preserved <see cref="ProductUserId" />.
		/// 
		/// Example walkthrough: Cross-platform mobile game using the anonymous Device ID login.
		/// 
		/// For onboarding new users, the game will attempt to always automatically login the local user
		/// by calling <see cref="Login" /> using the <see cref="ExternalCredentialType.DeviceidAccessToken" /> login type. If the local
		/// Device ID credentials are not found, and the game wants a frictionless entry for the first time
		/// user experience, the game will automatically call <see cref="CreateDeviceId" /> to create new
		/// Device ID pseudo-account and then login the local user into it. Consecutive game starts will
		/// thus automatically login the user to their locally persisted Device ID account.
		/// 
		/// The user starts playing anonymously using the Device ID login type and makes significant game progress.
		/// Later, they login using an external account that they have already used previously for the
		/// same game perhaps on another platform, or another game owned by the same organization.
		/// In such case, <see cref="Login" /> will automatically login the user to their existing account
		/// linking keychain and create automatically a new empty product user for this product.
		/// 
		/// In order for the user to use their existing previously created keychain and have the locally
		/// created Device ID login reference to that keychain instead, the user's current product user
		/// needs to be moved to be under that keychain so that their existing game progression will be
		/// preserved. To do so, the game can call <see cref="TransferDeviceIdAccount" /> to transfer the
		/// Device ID login and the product user associated with it into the other keychain that has real
		/// external user account(s) linked to it. Note that it is important that the game either automatically
		/// checks that the other product user does not have any meaningful progression data, or otherwise
		/// will prompt the user to make the choice on which game progression to preserve and which can
		/// be discarded permanently. The other product user will be discarded permanently and cannot be
		/// recovered, so it is very important that the user is guided to make the right choice to avoid
		/// accidental loss of all game progression.
		/// <seealso cref="Login" />
		/// <seealso cref="CreateDeviceId" />
		/// </summary>
		/// <param name="options">structure containing the logged in product users and specifying which one will be preserved</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">a callback that is fired when the transfer operation completes, either successfully or in error</param>
		public void TransferDeviceIdAccount(TransferDeviceIdAccountOptions options, object clientData, OnTransferDeviceIdAccountCallback completionDelegate)
		{
			var optionsInternal = Helper.CopyProperties<TransferDeviceIdAccountOptionsInternal>(options);

			var completionDelegateInternal = new OnTransferDeviceIdAccountCallbackInternal(OnTransferDeviceIdAccount);
			var clientDataAddress = IntPtr.Zero;
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			EOS_Connect_TransferDeviceIdAccount(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);
			Helper.TryMarshalDispose(ref optionsInternal);
		}

		/// <summary>
		/// Retrieve the equivalent Product User IDs from a list of external account IDs from supported account providers. The values will be cached and retrievable through <see cref="GetExternalAccountMapping" />.
		/// </summary>
		/// <param name="options">structure containing a list of external account IDs, in string form, to query for the Product User ID representation</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">a callback that is fired when the query operation completes, either successfully or in error</param>
		public void QueryExternalAccountMappings(QueryExternalAccountMappingsOptions options, object clientData, OnQueryExternalAccountMappingsCallback completionDelegate)
		{
			var optionsInternal = Helper.CopyProperties<QueryExternalAccountMappingsOptionsInternal>(options);

			var completionDelegateInternal = new OnQueryExternalAccountMappingsCallbackInternal(OnQueryExternalAccountMappings);
			var clientDataAddress = IntPtr.Zero;
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			EOS_Connect_QueryExternalAccountMappings(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);
			Helper.TryMarshalDispose(ref optionsInternal);
		}

		/// <summary>
		/// Retrieve the equivalent external account mappings from a list of Product User IDs.
		/// This will include data for each external account info found for the linked product IDs.
		/// 
		/// The values will be cached and retrievable via <see cref="GetProductUserIdMapping" />, <see cref="CopyProductUserExternalAccountByIndex" />,
		/// <see cref="CopyProductUserExternalAccountByAccountType" /> or <see cref="CopyProductUserExternalAccountByAccountId" />.
		/// <seealso cref="ExternalAccountInfo" />
		/// <seealso cref="GetProductUserExternalAccountCount" />
		/// <seealso cref="GetProductUserIdMapping" />
		/// <seealso cref="CopyProductUserExternalAccountByIndex" />
		/// <seealso cref="CopyProductUserExternalAccountByAccountType" />
		/// <seealso cref="CopyProductUserExternalAccountByAccountId" />
		/// <seealso cref="CopyProductUserInfo" />
		/// </summary>
		/// <param name="options">structure containing a list of Product User IDs to query for the external account representation</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the CompletionDelegate</param>
		/// <param name="completionDelegate">a callback that is fired when the query operation completes, either successfully or in error</param>
		public void QueryProductUserIdMappings(QueryProductUserIdMappingsOptions options, object clientData, OnQueryProductUserIdMappingsCallback completionDelegate)
		{
			var optionsInternal = Helper.CopyProperties<QueryProductUserIdMappingsOptionsInternal>(options);

			var completionDelegateInternal = new OnQueryProductUserIdMappingsCallbackInternal(OnQueryProductUserIdMappings);
			var clientDataAddress = IntPtr.Zero;
			Helper.AddCallback(ref clientDataAddress, clientData, completionDelegate, completionDelegateInternal);

			EOS_Connect_QueryProductUserIdMappings(InnerHandle, ref optionsInternal, clientDataAddress, completionDelegateInternal);
			Helper.TryMarshalDispose(ref optionsInternal);
		}

		/// <summary>
		/// Fetch a Product User ID that maps to an external account ID cached from a previous query
		/// </summary>
		/// <param name="options">structure containing the local user and target external account ID</param>
		/// <returns>
		/// The Product User ID, previously retrieved from the backend service, for the given target external account
		/// </returns>
		public ProductUserId GetExternalAccountMapping(GetExternalAccountMappingsOptions options)
		{
			var optionsInternal = Helper.CopyProperties<GetExternalAccountMappingsOptionsInternal>(options);

			var funcResult = EOS_Connect_GetExternalAccountMapping(InnerHandle, ref optionsInternal);
			Helper.TryMarshalDispose(ref optionsInternal);

			var funcResultReturn = Helper.GetDefault<ProductUserId>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Fetch an external account ID, in string form, that maps to a given Product User ID
		/// </summary>
		/// <param name="options">structure containing the local user and target Product User ID</param>
		/// <param name="outBuffer">The buffer into which the external account ID data should be written. The buffer must be long enough to hold a string of <see cref="ExternalAccountIdMaxLength" />.</param>
		/// <param name="inOutBufferLength">
		/// The size of the OutBuffer in characters.
		/// The input buffer should include enough space to be null-terminated.
		/// When the function returns, this parameter will be filled with the length of the string copied into OutBuffer.
		/// </param>
		/// <returns>
		/// An <see cref="Result" /> that indicates the external account ID was copied into the OutBuffer
		/// <see cref="Result.Success" /> if the information is available and passed out in OutUserInfo
		/// <see cref="Result.InvalidParameters" /> if you pass a null pointer for the out parameter
		/// <see cref="Result.NotFound" /> if the mapping doesn't exist or hasn't been queried yet
		/// <see cref="Result.LimitExceeded" /> - The OutBuffer is not large enough to receive the external account ID. InOutBufferLength contains the required minimum length to perform the operation successfully.
		/// </returns>
		public Result GetProductUserIdMapping(GetProductUserIdMappingOptions options, System.Text.StringBuilder outBuffer, ref int inOutBufferLength)
		{
			var optionsInternal = Helper.CopyProperties<GetProductUserIdMappingOptionsInternal>(options);

			var funcResult = EOS_Connect_GetProductUserIdMapping(InnerHandle, ref optionsInternal, outBuffer, ref inOutBufferLength);
			Helper.TryMarshalDispose(ref optionsInternal);

			var funcResultReturn = Helper.GetDefault<Result>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Fetch the number of linked external accounts for a Product User ID.
		/// <seealso cref="CopyProductUserExternalAccountByIndex" />
		/// </summary>
		/// <param name="options">The Options associated with retrieving the external account info count.</param>
		/// <returns>
		/// Number of external accounts or 0 otherwise
		/// </returns>
		public uint GetProductUserExternalAccountCount(GetProductUserExternalAccountCountOptions options)
		{
			var optionsInternal = Helper.CopyProperties<GetProductUserExternalAccountCountOptionsInternal>(options);

			var funcResult = EOS_Connect_GetProductUserExternalAccountCount(InnerHandle, ref optionsInternal);
			Helper.TryMarshalDispose(ref optionsInternal);

			var funcResultReturn = Helper.GetDefault<uint>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Fetch information about an external account linked to a Product User ID.
		/// On a successful call, the caller must release the returned structure using the <see cref="Release" /> API.
		/// <seealso cref="Release" />
		/// </summary>
		/// <param name="options">Structure containing the target index.</param>
		/// <param name="outExternalAccountInfo">The external account info data for the user with given index.</param>
		/// <returns>
		/// An <see cref="Result" /> that indicates the external account data was copied into the OutExternalAccountInfo
		/// <see cref="Result.Success" /> if the information is available and passed out in OutExternalAccountInfo
		/// <see cref="Result.InvalidParameters" /> if you pass a null pointer for the out parameter
		/// <see cref="Result.NotFound" /> if the account data doesn't exist or hasn't been queried yet
		/// </returns>
		public Result CopyProductUserExternalAccountByIndex(CopyProductUserExternalAccountByIndexOptions options, out ExternalAccountInfo outExternalAccountInfo)
		{
			var optionsInternal = Helper.CopyProperties<CopyProductUserExternalAccountByIndexOptionsInternal>(options);

			outExternalAccountInfo = Helper.GetDefault<ExternalAccountInfo>();

			var outExternalAccountInfoAddress = IntPtr.Zero;

			var funcResult = EOS_Connect_CopyProductUserExternalAccountByIndex(InnerHandle, ref optionsInternal, ref outExternalAccountInfoAddress);
			Helper.TryMarshalDispose(ref optionsInternal);

			if (Helper.TryMarshalGet<ExternalAccountInfoInternal, ExternalAccountInfo>(outExternalAccountInfoAddress, out outExternalAccountInfo))
			{
				EOS_Connect_ExternalAccountInfo_Release(outExternalAccountInfoAddress);
			}

			var funcResultReturn = Helper.GetDefault<Result>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Fetch information about an external account of a specific type linked to a Product User ID.
		/// On a successful call, the caller must release the returned structure using the <see cref="Release" /> API.
		/// <seealso cref="Release" />
		/// </summary>
		/// <param name="options">Structure containing the target external account type.</param>
		/// <param name="outExternalAccountInfo">The external account info data for the user with given external account type.</param>
		/// <returns>
		/// An <see cref="Result" /> that indicates the external account data was copied into the OutExternalAccountInfo
		/// <see cref="Result.Success" /> if the information is available and passed out in OutExternalAccountInfo
		/// <see cref="Result.InvalidParameters" /> if you pass a null pointer for the out parameter
		/// <see cref="Result.NotFound" /> if the account data doesn't exist or hasn't been queried yet
		/// </returns>
		public Result CopyProductUserExternalAccountByAccountType(CopyProductUserExternalAccountByAccountTypeOptions options, out ExternalAccountInfo outExternalAccountInfo)
		{
			var optionsInternal = Helper.CopyProperties<CopyProductUserExternalAccountByAccountTypeOptionsInternal>(options);

			outExternalAccountInfo = Helper.GetDefault<ExternalAccountInfo>();

			var outExternalAccountInfoAddress = IntPtr.Zero;

			var funcResult = EOS_Connect_CopyProductUserExternalAccountByAccountType(InnerHandle, ref optionsInternal, ref outExternalAccountInfoAddress);
			Helper.TryMarshalDispose(ref optionsInternal);

			if (Helper.TryMarshalGet<ExternalAccountInfoInternal, ExternalAccountInfo>(outExternalAccountInfoAddress, out outExternalAccountInfo))
			{
				EOS_Connect_ExternalAccountInfo_Release(outExternalAccountInfoAddress);
			}

			var funcResultReturn = Helper.GetDefault<Result>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Fetch information about an external account linked to a Product User ID.
		/// On a successful call, the caller must release the returned structure using the <see cref="Release" /> API.
		/// <seealso cref="Release" />
		/// </summary>
		/// <param name="options">Structure containing the target external account ID.</param>
		/// <param name="outExternalAccountInfo">The external account info data for the user with given external account ID.</param>
		/// <returns>
		/// An <see cref="Result" /> that indicates the external account data was copied into the OutExternalAccountInfo
		/// <see cref="Result.Success" /> if the information is available and passed out in OutExternalAccountInfo
		/// <see cref="Result.InvalidParameters" /> if you pass a null pointer for the out parameter
		/// <see cref="Result.NotFound" /> if the account data doesn't exist or hasn't been queried yet
		/// </returns>
		public Result CopyProductUserExternalAccountByAccountId(CopyProductUserExternalAccountByAccountIdOptions options, out ExternalAccountInfo outExternalAccountInfo)
		{
			var optionsInternal = Helper.CopyProperties<CopyProductUserExternalAccountByAccountIdOptionsInternal>(options);

			outExternalAccountInfo = Helper.GetDefault<ExternalAccountInfo>();

			var outExternalAccountInfoAddress = IntPtr.Zero;

			var funcResult = EOS_Connect_CopyProductUserExternalAccountByAccountId(InnerHandle, ref optionsInternal, ref outExternalAccountInfoAddress);
			Helper.TryMarshalDispose(ref optionsInternal);

			if (Helper.TryMarshalGet<ExternalAccountInfoInternal, ExternalAccountInfo>(outExternalAccountInfoAddress, out outExternalAccountInfo))
			{
				EOS_Connect_ExternalAccountInfo_Release(outExternalAccountInfoAddress);
			}

			var funcResultReturn = Helper.GetDefault<Result>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Fetch information about a Product User, using the external account that they most recently logged in with as the reference.
		/// On a successful call, the caller must release the returned structure using the <see cref="Release" /> API.
		/// <seealso cref="Release" />
		/// </summary>
		/// <param name="options">Structure containing the target external account ID.</param>
		/// <param name="outExternalAccountInfo">The external account info data last logged in for the user.</param>
		/// <returns>
		/// An <see cref="Result" /> that indicates the external account data was copied into the OutExternalAccountInfo
		/// <see cref="Result.Success" /> if the information is available and passed out in OutExternalAccountInfo
		/// <see cref="Result.InvalidParameters" /> if you pass a null pointer for the out parameter
		/// <see cref="Result.NotFound" /> if the account data doesn't exist or hasn't been queried yet
		/// </returns>
		public Result CopyProductUserInfo(CopyProductUserInfoOptions options, out ExternalAccountInfo outExternalAccountInfo)
		{
			var optionsInternal = Helper.CopyProperties<CopyProductUserInfoOptionsInternal>(options);

			outExternalAccountInfo = Helper.GetDefault<ExternalAccountInfo>();

			var outExternalAccountInfoAddress = IntPtr.Zero;

			var funcResult = EOS_Connect_CopyProductUserInfo(InnerHandle, ref optionsInternal, ref outExternalAccountInfoAddress);
			Helper.TryMarshalDispose(ref optionsInternal);

			if (Helper.TryMarshalGet<ExternalAccountInfoInternal, ExternalAccountInfo>(outExternalAccountInfoAddress, out outExternalAccountInfo))
			{
				EOS_Connect_ExternalAccountInfo_Release(outExternalAccountInfoAddress);
			}

			var funcResultReturn = Helper.GetDefault<Result>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Fetch the number of product users that are logged in.
		/// </summary>
		/// <returns>
		/// the number of product users logged in.
		/// </returns>
		public int GetLoggedInUsersCount()
		{
			var funcResult = EOS_Connect_GetLoggedInUsersCount(InnerHandle);
			var funcResultReturn = Helper.GetDefault<int>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Fetch a Product User ID that is logged in. This Product User ID is in the Epic Online Services namespace
		/// </summary>
		/// <param name="index">an index into the list of logged in users. If the index is out of bounds, the returned Product User ID will be invalid.</param>
		/// <returns>
		/// the Product User ID associated with the index passed
		/// </returns>
		public ProductUserId GetLoggedInUserByIndex(int index)
		{
			var funcResult = EOS_Connect_GetLoggedInUserByIndex(InnerHandle, index);
			var funcResultReturn = Helper.GetDefault<ProductUserId>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Fetches the login status for an Product User ID. This Product User ID is considered logged in as long as the underlying access token has not expired.
		/// </summary>
		/// <param name="localUserId">the Product User ID of the user being queried</param>
		/// <returns>
		/// the enum value of a user's login status
		/// </returns>
		public LoginStatus GetLoginStatus(ProductUserId localUserId)
		{
			var funcResult = EOS_Connect_GetLoginStatus(InnerHandle, localUserId.InnerHandle);
			var funcResultReturn = Helper.GetDefault<LoginStatus>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Register to receive upcoming authentication expiration notifications.
		/// Notification is approximately 10 minutes prior to expiration.
		/// Call <see cref="Login" /> again with valid third party credentials to refresh access
		/// 
		/// @note must call RemoveNotifyAuthExpiration to remove the notification
		/// </summary>
		/// <param name="options">structure containing the API version of the callback to use</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the callback</param>
		/// <param name="notification">a callback that is fired when the authentication is about to expire</param>
		/// <returns>
		/// handle representing the registered callback
		/// </returns>
		public ulong AddNotifyAuthExpiration(AddNotifyAuthExpirationOptions options, object clientData, OnAuthExpirationCallback notification)
		{
			var optionsInternal = Helper.CopyProperties<AddNotifyAuthExpirationOptionsInternal>(options);

			var notificationInternal = new OnAuthExpirationCallbackInternal(OnAuthExpiration);
			var clientDataAddress = IntPtr.Zero;
			Helper.AddCallback(ref clientDataAddress, clientData, notification, notificationInternal);

			var funcResult = EOS_Connect_AddNotifyAuthExpiration(InnerHandle, ref optionsInternal, clientDataAddress, notificationInternal);
			Helper.TryMarshalDispose(ref optionsInternal);

			Helper.TryAssignNotificationIdToCallback(clientDataAddress, funcResult);

			var funcResultReturn = Helper.GetDefault<ulong>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Unregister from receiving expiration notifications.
		/// </summary>
		/// <param name="inId">handle representing the registered callback</param>
		public void RemoveNotifyAuthExpiration(ulong inId)
		{
			Helper.TryRemoveCallbackByNotificationId(inId);
			EOS_Connect_RemoveNotifyAuthExpiration(InnerHandle, inId);
		}

		/// <summary>
		/// Register to receive user login status updates.
		/// @note must call RemoveNotifyLoginStatusChanged to remove the notification
		/// </summary>
		/// <param name="options">structure containing the API version of the callback to use</param>
		/// <param name="clientData">arbitrary data that is passed back to you in the callback</param>
		/// <param name="notification">a callback that is fired when the login status for a user changes</param>
		/// <returns>
		/// handle representing the registered callback
		/// </returns>
		public ulong AddNotifyLoginStatusChanged(AddNotifyLoginStatusChangedOptions options, object clientData, OnLoginStatusChangedCallback notification)
		{
			var optionsInternal = Helper.CopyProperties<AddNotifyLoginStatusChangedOptionsInternal>(options);

			var notificationInternal = new OnLoginStatusChangedCallbackInternal(OnLoginStatusChanged);
			var clientDataAddress = IntPtr.Zero;
			Helper.AddCallback(ref clientDataAddress, clientData, notification, notificationInternal);

			var funcResult = EOS_Connect_AddNotifyLoginStatusChanged(InnerHandle, ref optionsInternal, clientDataAddress, notificationInternal);
			Helper.TryMarshalDispose(ref optionsInternal);

			Helper.TryAssignNotificationIdToCallback(clientDataAddress, funcResult);

			var funcResultReturn = Helper.GetDefault<ulong>();
			Helper.TryMarshalGet(funcResult, out funcResultReturn);
			return funcResultReturn;
		}

		/// <summary>
		/// Unregister from receiving user login status updates.
		/// </summary>
		/// <param name="inId">handle representing the registered callback</param>
		public void RemoveNotifyLoginStatusChanged(ulong inId)
		{
			Helper.TryRemoveCallbackByNotificationId(inId);
			EOS_Connect_RemoveNotifyLoginStatusChanged(InnerHandle, inId);
		}

		[MonoPInvokeCallback]
		internal static void OnLoginStatusChanged(IntPtr address)
		{
			OnLoginStatusChangedCallback callback = null;
			LoginStatusChangedCallbackInfo callbackInfo = null;
			if (Helper.TryGetAndRemoveCallback<OnLoginStatusChangedCallback, LoginStatusChangedCallbackInfoInternal, LoginStatusChangedCallbackInfo>(address, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback]
		internal static void OnAuthExpiration(IntPtr address)
		{
			OnAuthExpirationCallback callback = null;
			AuthExpirationCallbackInfo callbackInfo = null;
			if (Helper.TryGetAndRemoveCallback<OnAuthExpirationCallback, AuthExpirationCallbackInfoInternal, AuthExpirationCallbackInfo>(address, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback]
		internal static void OnQueryProductUserIdMappings(IntPtr address)
		{
			OnQueryProductUserIdMappingsCallback callback = null;
			QueryProductUserIdMappingsCallbackInfo callbackInfo = null;
			if (Helper.TryGetAndRemoveCallback<OnQueryProductUserIdMappingsCallback, QueryProductUserIdMappingsCallbackInfoInternal, QueryProductUserIdMappingsCallbackInfo>(address, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback]
		internal static void OnQueryExternalAccountMappings(IntPtr address)
		{
			OnQueryExternalAccountMappingsCallback callback = null;
			QueryExternalAccountMappingsCallbackInfo callbackInfo = null;
			if (Helper.TryGetAndRemoveCallback<OnQueryExternalAccountMappingsCallback, QueryExternalAccountMappingsCallbackInfoInternal, QueryExternalAccountMappingsCallbackInfo>(address, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback]
		internal static void OnTransferDeviceIdAccount(IntPtr address)
		{
			OnTransferDeviceIdAccountCallback callback = null;
			TransferDeviceIdAccountCallbackInfo callbackInfo = null;
			if (Helper.TryGetAndRemoveCallback<OnTransferDeviceIdAccountCallback, TransferDeviceIdAccountCallbackInfoInternal, TransferDeviceIdAccountCallbackInfo>(address, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback]
		internal static void OnDeleteDeviceId(IntPtr address)
		{
			OnDeleteDeviceIdCallback callback = null;
			DeleteDeviceIdCallbackInfo callbackInfo = null;
			if (Helper.TryGetAndRemoveCallback<OnDeleteDeviceIdCallback, DeleteDeviceIdCallbackInfoInternal, DeleteDeviceIdCallbackInfo>(address, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback]
		internal static void OnCreateDeviceId(IntPtr address)
		{
			OnCreateDeviceIdCallback callback = null;
			CreateDeviceIdCallbackInfo callbackInfo = null;
			if (Helper.TryGetAndRemoveCallback<OnCreateDeviceIdCallback, CreateDeviceIdCallbackInfoInternal, CreateDeviceIdCallbackInfo>(address, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback]
		internal static void OnUnlinkAccount(IntPtr address)
		{
			OnUnlinkAccountCallback callback = null;
			UnlinkAccountCallbackInfo callbackInfo = null;
			if (Helper.TryGetAndRemoveCallback<OnUnlinkAccountCallback, UnlinkAccountCallbackInfoInternal, UnlinkAccountCallbackInfo>(address, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback]
		internal static void OnLinkAccount(IntPtr address)
		{
			OnLinkAccountCallback callback = null;
			LinkAccountCallbackInfo callbackInfo = null;
			if (Helper.TryGetAndRemoveCallback<OnLinkAccountCallback, LinkAccountCallbackInfoInternal, LinkAccountCallbackInfo>(address, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback]
		internal static void OnCreateUser(IntPtr address)
		{
			OnCreateUserCallback callback = null;
			CreateUserCallbackInfo callbackInfo = null;
			if (Helper.TryGetAndRemoveCallback<OnCreateUserCallback, CreateUserCallbackInfoInternal, CreateUserCallbackInfo>(address, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[MonoPInvokeCallback]
		internal static void OnLogin(IntPtr address)
		{
			OnLoginCallback callback = null;
			LoginCallbackInfo callbackInfo = null;
			if (Helper.TryGetAndRemoveCallback<OnLoginCallback, LoginCallbackInfoInternal, LoginCallbackInfo>(address, out callback, out callbackInfo))
			{
				callback(callbackInfo);
			}
		}

		[DllImport(Config.BinaryName)]
		private static extern void EOS_Connect_ExternalAccountInfo_Release(IntPtr externalAccountInfo);

		[DllImport(Config.BinaryName)]
		private static extern void EOS_Connect_RemoveNotifyLoginStatusChanged(IntPtr handle, ulong inId);

		[DllImport(Config.BinaryName)]
		private static extern ulong EOS_Connect_AddNotifyLoginStatusChanged(IntPtr handle, ref AddNotifyLoginStatusChangedOptionsInternal options, IntPtr clientData, OnLoginStatusChangedCallbackInternal notification);

		[DllImport(Config.BinaryName)]
		private static extern void EOS_Connect_RemoveNotifyAuthExpiration(IntPtr handle, ulong inId);

		[DllImport(Config.BinaryName)]
		private static extern ulong EOS_Connect_AddNotifyAuthExpiration(IntPtr handle, ref AddNotifyAuthExpirationOptionsInternal options, IntPtr clientData, OnAuthExpirationCallbackInternal notification);

		[DllImport(Config.BinaryName)]
		private static extern LoginStatus EOS_Connect_GetLoginStatus(IntPtr handle, IntPtr localUserId);

		[DllImport(Config.BinaryName)]
		private static extern IntPtr EOS_Connect_GetLoggedInUserByIndex(IntPtr handle, int index);

		[DllImport(Config.BinaryName)]
		private static extern int EOS_Connect_GetLoggedInUsersCount(IntPtr handle);

		[DllImport(Config.BinaryName)]
		private static extern Result EOS_Connect_CopyProductUserInfo(IntPtr handle, ref CopyProductUserInfoOptionsInternal options, ref IntPtr outExternalAccountInfo);

		[DllImport(Config.BinaryName)]
		private static extern Result EOS_Connect_CopyProductUserExternalAccountByAccountId(IntPtr handle, ref CopyProductUserExternalAccountByAccountIdOptionsInternal options, ref IntPtr outExternalAccountInfo);

		[DllImport(Config.BinaryName)]
		private static extern Result EOS_Connect_CopyProductUserExternalAccountByAccountType(IntPtr handle, ref CopyProductUserExternalAccountByAccountTypeOptionsInternal options, ref IntPtr outExternalAccountInfo);

		[DllImport(Config.BinaryName)]
		private static extern Result EOS_Connect_CopyProductUserExternalAccountByIndex(IntPtr handle, ref CopyProductUserExternalAccountByIndexOptionsInternal options, ref IntPtr outExternalAccountInfo);

		[DllImport(Config.BinaryName)]
		private static extern uint EOS_Connect_GetProductUserExternalAccountCount(IntPtr handle, ref GetProductUserExternalAccountCountOptionsInternal options);

		[DllImport(Config.BinaryName)]
		private static extern Result EOS_Connect_GetProductUserIdMapping(IntPtr handle, ref GetProductUserIdMappingOptionsInternal options, System.Text.StringBuilder outBuffer, ref int inOutBufferLength);

		[DllImport(Config.BinaryName)]
		private static extern IntPtr EOS_Connect_GetExternalAccountMapping(IntPtr handle, ref GetExternalAccountMappingsOptionsInternal options);

		[DllImport(Config.BinaryName)]
		private static extern void EOS_Connect_QueryProductUserIdMappings(IntPtr handle, ref QueryProductUserIdMappingsOptionsInternal options, IntPtr clientData, OnQueryProductUserIdMappingsCallbackInternal completionDelegate);

		[DllImport(Config.BinaryName)]
		private static extern void EOS_Connect_QueryExternalAccountMappings(IntPtr handle, ref QueryExternalAccountMappingsOptionsInternal options, IntPtr clientData, OnQueryExternalAccountMappingsCallbackInternal completionDelegate);

		[DllImport(Config.BinaryName)]
		private static extern void EOS_Connect_TransferDeviceIdAccount(IntPtr handle, ref TransferDeviceIdAccountOptionsInternal options, IntPtr clientData, OnTransferDeviceIdAccountCallbackInternal completionDelegate);

		[DllImport(Config.BinaryName)]
		private static extern void EOS_Connect_DeleteDeviceId(IntPtr handle, ref DeleteDeviceIdOptionsInternal options, IntPtr clientData, OnDeleteDeviceIdCallbackInternal completionDelegate);

		[DllImport(Config.BinaryName)]
		private static extern void EOS_Connect_CreateDeviceId(IntPtr handle, ref CreateDeviceIdOptionsInternal options, IntPtr clientData, OnCreateDeviceIdCallbackInternal completionDelegate);

		[DllImport(Config.BinaryName)]
		private static extern void EOS_Connect_UnlinkAccount(IntPtr handle, ref UnlinkAccountOptionsInternal options, IntPtr clientData, OnUnlinkAccountCallbackInternal completionDelegate);

		[DllImport(Config.BinaryName)]
		private static extern void EOS_Connect_LinkAccount(IntPtr handle, ref LinkAccountOptionsInternal options, IntPtr clientData, OnLinkAccountCallbackInternal completionDelegate);

		[DllImport(Config.BinaryName)]
		private static extern void EOS_Connect_CreateUser(IntPtr handle, ref CreateUserOptionsInternal options, IntPtr clientData, OnCreateUserCallbackInternal completionDelegate);

		[DllImport(Config.BinaryName)]
		private static extern void EOS_Connect_Login(IntPtr handle, ref LoginOptionsInternal options, IntPtr clientData, OnLoginCallbackInternal completionDelegate);
	}
}